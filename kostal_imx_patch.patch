diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 21df1c415f..b7f5920072 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1905,6 +1905,7 @@ source "board/hisilicon/hikey/Kconfig"
 source "board/hisilicon/hikey960/Kconfig"
 source "board/hisilicon/poplar/Kconfig"
 source "board/isee/igep003x/Kconfig"
+source "board/kostal/inverter/Kconfig"
 source "board/phytec/pcm051/Kconfig"
 source "board/silica/pengwyn/Kconfig"
 source "board/spear/spear300/Kconfig"
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 9900b44274..c45bdcfc1e 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -711,6 +711,7 @@ dtb-$(CONFIG_MX6ULL) += \
 	imx6ull-14x14-evk.dtb \
 	imx6ull-colibri.dtb \
 	imx6ull-phytec-segin-ff-rdk-emmc.dtb \
+	imx6ull-kie-inverter.dtb \
 	imx6ull-dart-6ul.dtb \
 	imx6ull-somlabs-visionsom.dtb \
 	imx6ulz-14x14-evk.dtb
diff --git a/arch/arm/dts/imx6ull-kie-inverter-u-boot.dtsi b/arch/arm/dts/imx6ull-kie-inverter-u-boot.dtsi
new file mode 100644
index 0000000000..f69f2d6001
--- /dev/null
+++ b/arch/arm/dts/imx6ull-kie-inverter-u-boot.dtsi
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 DENX Software Engineering GmbH
+ * Author: Lukasz Majewski <lukma@denx.de>
+ */
+
+&pca8574 {
+	u-boot,i2c-offset-len = <0>;
+};
diff --git a/arch/arm/dts/imx6ull-kie-inverter.dts b/arch/arm/dts/imx6ull-kie-inverter.dts
new file mode 100644
index 0000000000..17d69e8ffb
--- /dev/null
+++ b/arch/arm/dts/imx6ull-kie-inverter.dts
@@ -0,0 +1,363 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2024 Kostal Industrie Elektrik GmbH & Co. KG
+ * Copyright (C) 2024 Henry Hermanns <h.hermanns@kostal.com>
+ * 
+ * Copyright (C) 2019 DENX Software Engineering GmbH
+ * Author: Parthiban Nallathambi <pn@denx.de>
+ */
+/dts-v1/;
+
+#include "imx6ull.dtsi"
+/ {
+	model = "Kostal KIE imx6 Ultra Lite Inverter";
+	compatible = "kostal,imx6ull-inverter", "fsl,imx6ull";
+
+	aliases {
+		u-boot,dm-pre-reloc;
+		mmc0 = &usdhc2;
+		usb0 = &usbotg1;
+		display0 = &lcdif;
+		ethernet0 = &fec2;
+	};
+
+	backlight_display: backlight-display {
+		compatible = "gpio-backlight";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_backlight>;
+		gpios = <&gpio3 24 GPIO_ACTIVE_HIGH>;
+		default-on;
+		status = "okay";
+	};
+
+	chosen {
+		stdout-path = &uart1;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		green {
+			label = "green";
+			gpios = <&pca8574 6 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "gpio";
+			default-state = "off";
+		};
+
+		red {
+			label = "red";
+			gpios = <&pca8574 7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "gpio";
+			default-state = "off";
+		};
+	};
+
+	memory {
+		reg = <0x80000000 0x20000000>;
+	};
+
+	regulators: regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usbotg2_vbus: usbotg2-vbus@0 {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_otg2_vbus>;
+			regulator-name = "usb_otg2_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 4 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		VDD_in: regulator@1 {
+			compatible = "regulator-fixed";
+			regulator-name = "VDD_in";
+			regulator-min-microvolt = <12000000>;
+			regulator-max-microvolt = <12000000>;
+			regulator-always-on;
+			regulator-boot-on;
+		};
+
+		vcc_5v: regulator@2 {
+			compatible = "regulator-fixed";
+			regulator-name = "+5V";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+			vin-supply = <&VDD_in>;
+		};
+
+		reg_3v3: regulator@4 {
+			compatible = "regulator-fixed";
+			regulator-name = "3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+			vin-supply = <&vcc_5v>;
+		};
+
+		reg_1v8: regulator@5 {
+			compatible = "regulator-fixed";
+			regulator-name = "1V8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-always-on;
+			vin-supply = <&vcc_5v>;
+		};
+
+		reg_1v35: regulator@6 {
+			compatible = "regulator-fixed";
+			regulator-name = "1V35";
+			regulator-min-microvolt = <1350000>;
+			regulator-max-microvolt = <1350000>;
+			regulator-always-on;
+			vin-supply = <&vcc_5v>;
+		};
+
+
+/*
+		vbus_otg1: regulator@3 {
+			compatible = "regulator-fixed";
+			reg = <3>;
+			regulator-name = "vbus_otg1";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+		};
+*/
+	};
+
+/*
+	panel {
+		compatible = "sitronix,st7701";
+		backlight = <&backlight_display>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&display_out>;
+			};
+		};
+	};
+*/
+
+	watchdog: watchdog {
+		compatible = "linux,wdt-gpio";
+		gpios = <&gpio1 5 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&pinctrl_ext_wdog>;
+		hw_algo = "toggle";
+		hw_margin_ms = <1600>;
+		always-running;
+	};
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&vcc_5v>;
+	status = "okay";
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet2>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	phy-supply = <&reg_3v3>;
+	status = "okay";
+
+	/* Switch MV88E6020 at base address 0x10 when ADDR4=1 */
+	/* Proper initialization is performed with PHYLIB */
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@10 {
+			reg = <0x10>;
+		};
+	};
+};
+
+&i2c1 {
+	clock-frequency = <10000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pca8574: gpio@20 {
+		compatible = "nxp,pca8574";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		gpio-bank-name = "kbd";
+		lines-initial-states = <0xFF>;
+	};
+};
+
+/* TODO - Not yet working */
+/*
+&lcdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat
+		     &pinctrl_lcdif_ctrl>;
+	lcd-supply = <&reg_3v3>;
+	status = "okay";
+
+	port {
+		display_out: endpoint {
+			remote-endpoint = <&panel_in>;
+		};
+	};
+};
+*/
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	uart-has-rtscts;
+	status = "okay";
+};
+
+&usbotg1 {
+	/* TODO Fixed regulator needed? */
+	disable-over-current;
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usbotg2 {
+	vbus-supply = <&reg_usbotg2_vbus>;
+	disable-over-current;
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usdhc2 {
+	u-boot,dm-spl;
+	u-boot,dm-pre-reloc;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	bus-width = <8>;
+	non-removable;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+
+	pinctrl_enet2: enet2grp {
+		fsl,pins = <
+			MX6UL_PAD_GPIO1_IO06__ENET2_MDIO	0x10010
+			MX6UL_PAD_GPIO1_IO07__ENET2_MDC		0x10010
+			MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN	0x1b0b0
+			MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00	0x1b0b0
+			MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	0x1b0b0
+			MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	0x1b010
+			MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	0x1b010
+			MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	0x1b010
+			MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001b010
+			MX6UL_PAD_LCD_DATA13__GPIO3_IO18	0x17059
+			MX6UL_PAD_LCD_DATA14__GPIO3_IO19	0x17059
+		>;
+	};
+
+	pinctrl_ext_wdog: extwdoggrp {
+		fsl,pins = <
+			MX6UL_PAD_GPIO1_IO05__GPIO1_IO05	0x1b0b0
+			/* TODO WDT_SEL, no support in kernel for GPIO */
+			MX6UL_PAD_GPIO1_IO03__GPIO1_IO03	0x1b0b0
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			MX6UL_PAD_LCD_DATA08__FLEXCAN1_TX	0x1b020
+			MX6UL_PAD_LCD_DATA09__FLEXCAN1_RX	0x1b020
+			/* TODO STB - silent mode */
+			MX6UL_PAD_LCD_DATA10__GPIO3_IO15	0x1b0b0
+		>;
+	};
+
+	pinctrl_i2c1: i2cgrp {
+		fsl,pins = <
+			MX6UL_PAD_UART4_TX_DATA__I2C1_SCL	0x4001b8b0
+			MX6UL_PAD_UART4_RX_DATA__I2C1_SDA	0x4001b8b0
+			MX6UL_PAD_GPIO1_IO08__GPIO1_IO08	0x0b0b0
+		>;
+	};
+
+	pinctrl_lcdif_dat: lcdifdatgrp {
+		fsl,pins = <
+			MX6UL_PAD_LCD_DATA00__LCDIF_DATA00	0x79
+			MX6UL_PAD_LCD_DATA01__LCDIF_DATA01	0x79
+			MX6UL_PAD_LCD_DATA02__LCDIF_DATA02	0x79
+			MX6UL_PAD_LCD_DATA03__LCDIF_DATA03	0x79
+			MX6UL_PAD_LCD_DATA04__LCDIF_DATA04	0x79
+			MX6UL_PAD_LCD_DATA05__LCDIF_DATA05	0x79
+			MX6UL_PAD_LCD_DATA06__LCDIF_DATA06	0x79
+			MX6UL_PAD_LCD_DATA07__LCDIF_DATA07	0x79
+		>;
+	};
+
+	pinctrl_lcdif_ctrl: lcdifctrlgrp {
+		fsl,pins = <
+			MX6UL_PAD_LCD_CLK__LCDIF_CLK		0x79
+			MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE	0x79
+			MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC	0x79
+			MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC	0x79
+			MX6UL_PAD_LCD_RESET__LCDIF_RESET	0x79
+		>;
+	};
+
+	pinctrl_backlight: backlightgrp {
+		fsl,pins = <
+			MX6UL_PAD_LCD_DATA19__GPIO3_IO24	0x1b0b1
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX	0x1b0b1
+			MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX	0x1b0b1
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1b0b1
+			MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1b0b1
+			MX6UL_PAD_UART2_CTS_B__UART2_DCE_CTS	0x1b0b1
+			MX6UL_PAD_UART2_RTS_B__UART2_DCE_RTS	0x1b0b1
+		>;
+	};
+
+	pinctrl_usb_otg2_vbus: usbotg2vbusgrp {
+		fsl,pins = <
+			MX6UL_PAD_GPIO1_IO04__GPIO1_IO04	0x10b0
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX6UL_PAD_NAND_WE_B__USDHC2_CMD 		0x170f9
+			MX6UL_PAD_NAND_RE_B__USDHC2_CLK   	0x100f9
+			MX6UL_PAD_NAND_DATA00__USDHC2_DATA0	0x170f9
+			MX6UL_PAD_NAND_DATA01__USDHC2_DATA1	0x170f9
+			MX6UL_PAD_NAND_DATA02__USDHC2_DATA2	0x170f9
+			MX6UL_PAD_NAND_DATA03__USDHC2_DATA3	0x170f9
+			MX6UL_PAD_NAND_DATA04__USDHC2_DATA4	0x170f9
+			MX6UL_PAD_NAND_DATA05__USDHC2_DATA5	0x170f9
+			MX6UL_PAD_NAND_DATA06__USDHC2_DATA6	0x170f9
+			MX6UL_PAD_NAND_DATA07__USDHC2_DATA7	0x170f9
+			MX6UL_PAD_NAND_ALE__USDHC2_RESET_B 	0x170f9
+		>;
+	};
+};
diff --git a/arch/arm/mach-imx/mx6/Kconfig b/arch/arm/mach-imx/mx6/Kconfig
index fa6e1112e6..9c5d63e241 100644
--- a/arch/arm/mach-imx/mx6/Kconfig
+++ b/arch/arm/mach-imx/mx6/Kconfig
@@ -256,6 +256,18 @@ config TARGET_GW_VENTANA
 	imply CMD_SATA
 	imply CMD_SPL
 
+config TARGET_KIE_INVERTER
+	bool "Kostal KIE i.MX6ULL"
+	select MX6ULL
+	select DM
+	select DM_ETH
+	select DM_GPIO
+	select DM_I2C
+	select DM_MMC
+	select DM_SERIAL
+	select DM_THERMAL
+	select SUPPORT_SPL
+
 config TARGET_KOSAGI_NOVENA
 	bool "Kosagi Novena"
 	select BOARD_LATE_INIT
diff --git a/board/kostal/inverter/Kconfig b/board/kostal/inverter/Kconfig
new file mode 100644
index 0000000000..28b712a122
--- /dev/null
+++ b/board/kostal/inverter/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_KIE_INVERTER
+
+config SYS_BOARD
+	default "inverter"
+
+config SYS_VENDOR
+	default "kostal"
+
+config SYS_CONFIG_NAME
+	default "imx6ull-inverter"
+
+endif
diff --git a/board/kostal/inverter/MAINTAINERS b/board/kostal/inverter/MAINTAINERS
new file mode 100644
index 0000000000..b855e26200
--- /dev/null
+++ b/board/kostal/inverter/MAINTAINERS
@@ -0,0 +1,6 @@
+INVERTER BOARD
+M:	Stefano Babic <sbabic@denx.de>
+S:	Maintained
+F:	board/kostal/inverter
+F:	include/configs/imx6ull-inverter.h
+F:	configs/kostal_kie_ull_defconfig
diff --git a/board/kostal/inverter/Makefile b/board/kostal/inverter/Makefile
new file mode 100644
index 0000000000..41ea8575ab
--- /dev/null
+++ b/board/kostal/inverter/Makefile
@@ -0,0 +1,7 @@
+# Copyright (C) 2018 Collabora Ltd.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := inverter.o
+obj-$(CONFIG_SPL_BUILD) += spl.o
diff --git a/board/kostal/inverter/inverter.c b/board/kostal/inverter/inverter.c
new file mode 100644
index 0000000000..042ddb4929
--- /dev/null
+++ b/board/kostal/inverter/inverter.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 DENX Software Engineeering GmbH
+ * Author: Parthiban Nallathambi <pn@denx.de>
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <fsl_esdhc_imx.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <usb.h>
+#include <led.h>
+#include <usb/ehci-ci.h>
+#include <asm/mach-imx/boot_mode.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+
+	return 0;
+}
+
+#ifdef CONFIG_FEC_MXC
+#define ENET_CLK_PAD_CTRL (PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_PAD_CTRL     (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE       | \
+			   PAD_CTL_SPEED_HIGH  | PAD_CTL_DSE_48ohm | \
+			   PAD_CTL_SRE_FAST)
+
+#define MDIO_PAD_CTRL     (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE      | \
+			   PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST | \
+			   PAD_CTL_ODE)
+
+#define RESET_PAD_CTRL     (PAD_CTL_DSE_48ohm  | PAD_CTL_SRE_SLOW | \
+			   PAD_CTL_ODE)
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__GPIO2_IO15 | MUX_PAD_CTRL(PAD_CTL_PUS_100K_DOWN |
+						       PAD_CTL_DSE_48ohm |
+						       PAD_CTL_SRE_SLOW),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const phy_reset_pads[] = {
+	MX6_PAD_LCD_DATA17__GPIO3_IO22 | MUX_PAD_CTRL(RESET_PAD_CTRL),
+};
+
+static void setup_iomux_fec(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	clrsetbits_le32(&iomuxc_regs->gpr[1],
+			IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK,
+			IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK);
+
+	setup_iomux_fec();
+	imx_iomux_v3_setup_multiple_pads(phy_reset_pads,
+					 ARRAY_SIZE(phy_reset_pads));
+
+	/* According to spec - mv88e6020 requires 10ms+ RESETn to be low */
+	gpio_request(IMX_GPIO_NR(3, 22), "RESET_SW");
+	gpio_direction_output(IMX_GPIO_NR(3, 22), 0);
+	mdelay(15);
+	gpio_set_value(IMX_GPIO_NR(3, 22), 1);
+	mdelay(20);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_FEC_MXC
+	setup_iomux_fec();
+#endif
+	return 0;
+}
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 8 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x60, 0x48, 0x00, 0x00)},
+	//{"emmc", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+	return 0;
+}
+
+int board_late_init(void)
+{
+	u32 cpurev = get_cpu_rev();
+	const char *soc_type = get_imx_type((cpurev & 0xFF000) >> 12);
+	char p[sizeof(soc_type)];
+
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+	if (IS_ENABLED(CONFIG_LED))
+		led_default_state();
+
+	/* Convert to lower case */
+	strcpy(p, soc_type);
+	for(int i = 0; p[i]; i++)
+		p[i] = tolower(p[i]);
+
+	env_set("soc_type", p);
+	return 0;
+}
+
+int checkboard(void)
+{
+	u32 cpurev = get_cpu_rev();
+
+	printf("Board: Kostal KIE inverter-i.MX%s\n",
+	      get_imx_type((cpurev & 0xFF000) >> 12));
+
+	return 0;
+}
diff --git a/board/kostal/inverter/spl.c b/board/kostal/inverter/spl.c
new file mode 100644
index 0000000000..9b6a029d07
--- /dev/null
+++ b/board/kostal/inverter/spl.c
@@ -0,0 +1,171 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 DENX Software Engineeering GmbH
+ * Author: Parthiban Nallathambi <pn@denx.de>
+ */
+
+#include <common.h>
+#include <spl.h>
+#include <asm/arch/clock.h>
+#include <asm/io.h>
+#include <asm/arch/mx6-ddr.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/sys_proto.h>
+#include <fsl_esdhc_imx.h>
+#include <init.h>
+
+/* Configuration for Micron MT41K256M16TW-107 IT:P, 32M x 16 x 8 -> 256MiB */
+
+/* TODO - Understand the DRAM settings with datasheet and all confifs
+ * FIXME - Does all the lines and configuration done, still something pending
+ */
+static struct mx6ul_iomux_grp_regs mx6_grp_ioregs = {
+	.grp_addds = 0x00000030,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_b0ds = 0x00000030,
+	.grp_ctlds = 0x00000030,
+	.grp_b1ds = 0x00000030,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+	.grp_ddr_type = 0x000c0000,
+};
+
+static struct mx6ul_iomux_ddr_regs mx6_ddr_ioregs = {
+	.dram_dqm0 = 0x00000030,
+	.dram_dqm1 = 0x00000030,
+	.dram_ras = 0x00000030,
+	.dram_cas = 0x00000030,
+	.dram_odt0 = 0x00000030,
+	.dram_odt1 = 0x00000030,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdclk_0 = 0x00000030,
+	.dram_sdqs0 = 0x00000030,
+	.dram_sdqs1 = 0x00000030,
+	.dram_reset = 0x00000030,
+};
+
+static struct mx6_mmdc_calibration mx6_mmcd_calib = {
+	.p0_mpwldectrl0 = 0x00000000,
+	.p0_mpdgctrl0 = 0x41480148,
+	.p0_mprddlctl = 0x40403E42,
+	.p0_mpwrdlctl = 0x40405852,
+};
+
+struct mx6_ddr_sysinfo ddr_sysinfo = {
+	.dsize = 0,		/* Bus size = 16bit */
+	.cs_density = 20,
+	.ncs = 1,
+	.cs1_mirror = 0,
+	.rtt_wr = 1,
+	.rtt_nom = 1,
+	.walat = 1,		/* Write additional latency */
+	.ralat = 5,		/* Read additional latency */
+	.mif3_mode = 3,		/* Command prediction working mode */
+	.bi_on = 1,		/* Bank interleaving enabled */
+	.pd_fast_exit = 1,
+	.sde_to_rst = 0x10,	/* 14 cycles, 200us (JEDEC default) */
+	.rst_to_cke = 0x23,	/* 33 cycles, 500us (JEDEC default) */
+	.ddr_type = DDR_TYPE_DDR3,
+	.refsel = 1,		/* Refresh cycles at 32KHz */
+	.refr = 7,		/* 8 refresh commands per refresh cycle */
+};
+
+static struct mx6_ddr3_cfg mem_ddr = {
+	.mem_speed = 933,
+	.density = 4,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 15,
+	.coladdr = 10,
+	.pagesz = 1,
+	.trcd = 1391,
+	.trcmin = 4791,
+	.trasmin = 3400,
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0xFFFFFFFF, &ccm->CCGR0);
+	writel(0xFFFFFFFF, &ccm->CCGR1);
+	writel(0xFFFFFFFF, &ccm->CCGR2);
+	writel(0xFFFFFFFF, &ccm->CCGR3);
+	writel(0xFFFFFFFF, &ccm->CCGR4);
+	writel(0xFFFFFFFF, &ccm->CCGR5);
+	writel(0xFFFFFFFF, &ccm->CCGR6);
+}
+
+static void spl_dram_init(void)
+{
+	mx6ul_dram_iocfg(mem_ddr.width, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+	mx6_dram_cfg(&ddr_sysinfo, &mx6_mmcd_calib, &mem_ddr);
+}
+
+#ifdef CONFIG_FSL_ESDHC_IMX
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE         | PAD_CTL_PUE       | \
+			PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_MED | \
+			PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | \
+			PAD_CTL_HYS)
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_NAND_RE_B__USDHC2_CLK    | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD    | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_ALE__USDHC2_RESET_B | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static struct fsl_esdhc_cfg usdhc_cfg = {
+	.esdhc_base = USDHC2_BASE_ADDR,
+	.max_bus_width = 8,
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	return 1;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+
+	SETUP_IOMUX_PADS(usdhc2_pads);
+	usdhc_cfg.sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+
+	ret = fsl_esdhc_initialize(bis, &usdhc_cfg);
+	if (ret) {
+		printf("Warning: failed to initialize eMMC dev\n");
+		return ret;
+	}
+	return 0;
+}
+
+#endif /* CONFIG_FSL_ESDHC_IMX */
+
+void board_init_f(ulong dummy)
+{
+	ccgr_init();
+
+	/* Setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	/* Setup iomux and fec */
+	board_early_init_f();
+
+	/* Setup GP timer */
+	timer_init();
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+
+	/* DDR initialization */
+	spl_dram_init();
+}
diff --git a/cmd/fuse.c b/cmd/fuse.c
index e001619d17..a560b1d7ec 100644
--- a/cmd/fuse.c
+++ b/cmd/fuse.c
@@ -1,5 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0+
-/*
+/* 
+ * Copyright (C) 2024 Kostal Industrie Elektrik GmbH & Co. KG
+ * Copyright (C) 2024 Henry Hermanns <h.hermanns@kostal.com>
+ * 
  * (C) Copyright 2009-2013 ADVANSEE
  * Benoît Thébaudeau <benoit.thebaudeau@advansee.com>
  *
@@ -12,6 +15,7 @@
 #include <command.h>
 #include <console.h>
 #include <fuse.h>
+#include <mapmem.h>
 #include <linux/errno.h>
 
 static int strtou32(const char *str, unsigned int base, u32 *result)
@@ -45,7 +49,9 @@ static int do_fuse(struct cmd_tbl *cmdtp, int flag, int argc,
 {
 	const char *op = argc >= 2 ? argv[1] : NULL;
 	int confirmed = argc >= 3 && !strcmp(argv[2], "-y");
-	u32 bank, word, cnt, val;
+	u32 bank, word, cnt, val, cmp;
+	ulong addr;
+	void *buf, *start;
 	int ret, i;
 
 	argc -= 2 + confirmed;
@@ -73,6 +79,70 @@ static int do_fuse(struct cmd_tbl *cmdtp, int flag, int argc,
 			printf(" %.8x", val);
 		}
 		putc('\n');
+	} else if (!strcmp(op, "readm")) {
+		if (argc == 3)
+			cnt = 1;
+		else if (argc != 4 || strtou32(argv[3], 0, &cnt))
+			return CMD_RET_USAGE;
+
+		addr = simple_strtoul(argv[2], NULL, 16);
+
+		start = map_sysmem(addr, 4);
+		buf = start;
+
+		printf("Reading bank %u len %u to 0x%lx\n", bank, cnt, addr);
+		for (i = 0; i < cnt; i++, word++) {
+			ret = fuse_read(bank, word, &val);
+			if (ret)
+				goto err;
+
+			*((u32 *)buf) = val;
+			buf += 4;
+		}
+
+		unmap_sysmem(start);
+	} else if (!strcmp(op, "cmp")) {
+		if (argc != 3 || strtou32(argv[2], 0, &cmp))
+			return CMD_RET_USAGE;
+
+		printf("Comparing bank %u:\n", bank);
+		printf("\nWord 0x%.8x:", word);
+		printf("\nValue 0x%.8x:", cmp);
+
+		ret = fuse_read(bank, word, &val);
+		if (ret)
+			goto err;
+
+		printf("0x%.8x\n", val);
+		if (val != cmp) {
+			printf("failed\n");
+			return CMD_RET_FAILURE;
+		}
+		printf("passed\n");
+	} else if (!strcmp(op, "cmpm")) {
+		if (argc == 3)
+			cnt = 1;
+		else if (argc != 4 || strtou32(argv[3], 0, &cnt))
+			return CMD_RET_USAGE;
+
+		addr = simple_strtoul(argv[2], NULL, 16);
+
+		start = map_sysmem(addr, cnt*4);
+		buf = start;
+
+		printf("Comparing bank %u len %u with 0x%lx\n", bank, cnt, addr);
+
+		for (i = 0; i < cnt; i++, word++) {
+			ret = fuse_read(bank, word, &val);
+			if (ret)
+				goto err;
+
+			*((u32 *)buf) = val;
+			printf("\nWord 0x%.8x:", word);
+			buf += 4;
+		}
+		
+		unmap_sysmem(start);
 	} else if (!strcmp(op, "sense")) {
 		if (argc == 2)
 			cnt = 1;
@@ -107,6 +177,29 @@ static int do_fuse(struct cmd_tbl *cmdtp, int flag, int argc,
 			if (ret)
 				goto err;
 		}
+	} else if (!strcmp(op, "progm")) {
+		if (argc == 3)
+			cnt = 1;
+		else if (argc != 4 || strtou32(argv[3], 0, &cnt))
+			return CMD_RET_USAGE;
+
+		addr = simple_strtoul(argv[2], NULL, 16);
+
+		start = map_sysmem(addr, cnt*4);
+		buf = start;
+
+		for (i = 0; i < cnt; i++, word++) {
+			val = *((u32 *)buf);
+
+			printf("Programming bank %u word 0x%.8x to 0x%.8x...\n",
+					bank, word, val);
+			if (!confirmed && !confirm_prog())
+				return CMD_RET_FAILURE;
+			ret = fuse_prog(bank, word, val);
+			if (ret)
+				goto err;
+			buf += 4;
+		}
 	} else if (!strcmp(op, "override")) {
 		if (argc < 3)
 			return CMD_RET_USAGE;
@@ -137,10 +230,18 @@ U_BOOT_CMD(
 	"Fuse sub-system",
 	     "read <bank> <word> [<cnt>] - read 1 or 'cnt' fuse words,\n"
 	"    starting at 'word'\n"
+	"fuse cmp <bank> <word> <hexval> - compare 'hexval' to fuse\n"
+	"    at 'word'\n"
+	"fuse cmpm <bank> <word> <addr> [<cnt>]- compare 1 or 'cnt' memory at 'addr' to fuse\n"
+	"    at 'word'\n"
+	"fuse readm <bank> <word> <addr> [<cnt>] - read 1 or 'cnt' fuse words,\n"
+	"    starting at 'word' into memory at 'addr'\n"
 	"fuse sense <bank> <word> [<cnt>] - sense 1 or 'cnt' fuse words,\n"
 	"    starting at 'word'\n"
 	"fuse prog [-y] <bank> <word> <hexval> [<hexval>...] - program 1 or\n"
 	"    several fuse words, starting at 'word' (PERMANENT)\n"
+	"fuse progm [-y] <bank> <word> <addr> [<cnt>] - program 1 or several\n"
+	"    fuse words, starting at 'word' (PERMANENT)\n"
 	"fuse override <bank> <word> <hexval> [<hexval>...] - override 1 or\n"
 	"    several fuse words, starting at 'word'"
 );
diff --git a/configs/kostal_kie_ull_defconfig b/configs/kostal_kie_ull_defconfig
new file mode 100644
index 0000000000..0c4d545fd0
--- /dev/null
+++ b/configs/kostal_kie_ull_defconfig
@@ -0,0 +1,83 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_SYS_TEXT_BASE=0x87800000
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_ENV_SIZE=0x8000
+CONFIG_ENV_OFFSET=0x300000
+CONFIG_TARGET_KIE_INVERTER=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_BOOTCOUNT_BOOTLIMIT=3
+CONFIG_SYS_BOOTCOUNT_ADDR=0x20d8024
+CONFIG_NR_DRAM_BANKS=8
+CONFIG_SPL=y
+CONFIG_SYS_BOOTCOUNT_SINGLEWORD=y
+CONFIG_ENV_OFFSET_REDUND=0x310000
+CONFIG_IMX_HAB=y
+# CONFIG_CMD_DEKBLOB is not set
+CONFIG_SPL_TEXT_BASE=0x908000
+CONFIG_SMBIOS_PRODUCT_NAME="pcl063"
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_FIT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/spl_sd.cfg"
+CONFIG_BOOTDELAY=3
+# CONFIG_USE_BOOTCOMMAND is not set
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SUPPORT_EMMC_BOOT_OVERRIDE_PART_CONFIG=y
+CONFIG_SPL_USB_HOST_SUPPORT=y
+CONFIG_SPL_USB_GADGET=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_CMD_DM=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+# CONFIG_RANDOM_UUID is not set
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_SDP=y
+CONFIG_CMD_CACHE=y
+# CONFIG_ISO_PARTITION is not set
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="imx6ull-kie-inverter"
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_BOOTCOUNT_LIMIT=y
+CONFIG_PCF8575_GPIO=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_DM_I2C_GPIO=y
+CONFIG_SYS_I2C_MXC=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_FSL_USDHC=y
+CONFIG_PHYLIB=y
+CONFIG_MV88E61XX_SWITCH=y
+CONFIG_MV88E61XX_CPU_PORT=6
+CONFIG_MV88E61XX_PHY_PORTS=0x3
+CONFIG_MV88E61XX_FIXED_PORTS=0x0
+CONFIG_PHY_FIXED=y
+CONFIG_FEC_MXC=y
+CONFIG_MII=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX6=y
+CONFIG_DM_PMIC=y
+# CONFIG_SPL_PMIC_CHILDREN is not set
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_MXC_UART=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Phytec"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_LZO=y
+CONFIG_SMBIOS_MANUFACTURER="phytec"
+
+CONFIG_CMD_TFTPPUT=y
\ No newline at end of file
diff --git a/drivers/gpio/pcf8575_gpio.c b/drivers/gpio/pcf8575_gpio.c
index 1b9a18fe5d..f87a84a44b 100644
--- a/drivers/gpio/pcf8575_gpio.c
+++ b/drivers/gpio/pcf8575_gpio.c
@@ -12,15 +12,9 @@
  *
  * Copyright (C) 2007 David Brownell
  *
- */
-
-/*
- * NOTE: The driver and devicetree bindings are borrowed from Linux
- * Kernel, but driver does not support all PCF857x devices. It currently
- * supports PCF8575 16-bit expander by TI and NXP.
+ * Add support for 8 bit expanders - like pca8574
+ * Copyright (C) 2021 Lukasz Majewski - DENX Software Engineering
  *
- * TODO(vigneshr@ti.com):
- * Support 8 bit PCF857x compatible expanders.
  */
 
 #include <common.h>
@@ -33,8 +27,6 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 struct pcf8575_chip {
-	int gpio_count;		/* No. GPIOs supported by the chip */
-
 	/* NOTE:  these chips have strange "quasi-bidirectional" I/O pins.
 	 * We can't actually know whether a pin is configured (a) as output
 	 * and driving the signal low, or (b) as input and reporting a low
@@ -48,18 +40,17 @@ struct pcf8575_chip {
 	 * reset state.  Otherwise it flags pins to be driven low.
 	 */
 	unsigned int out;	/* software latch */
-	const char *bank_name;	/* Name of the expander bank */
 };
 
-/* Read/Write to 16-bit I/O expander */
+/* Read/Write to I/O expander */
 
-static int pcf8575_i2c_write_le16(struct udevice *dev, unsigned int word)
+static int pcf8575_i2c_write(struct udevice *dev, unsigned int word)
 {
 	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
 	u8 buf[2] = { word & 0xff, word >> 8, };
 	int ret;
 
-	ret = dm_i2c_write(dev, 0, buf, 2);
+	ret = dm_i2c_write(dev, 0, buf, dev_get_driver_data(dev));
 	if (ret)
 		printf("%s i2c write failed to addr %x\n", __func__,
 		       chip->chip_addr);
@@ -67,13 +58,13 @@ static int pcf8575_i2c_write_le16(struct udevice *dev, unsigned int word)
 	return ret;
 }
 
-static int pcf8575_i2c_read_le16(struct udevice *dev)
+static int pcf8575_i2c_read(struct udevice *dev)
 {
 	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
-	u8 buf[2];
+	u8 buf[2] = {0x00, 0x00};
 	int ret;
 
-	ret = dm_i2c_read(dev, 0, buf, 2);
+	ret = dm_i2c_read(dev, 0, buf, dev_get_driver_data(dev));
 	if (ret) {
 		printf("%s i2c read failed from addr %x\n", __func__,
 		       chip->chip_addr);
@@ -89,7 +80,7 @@ static int pcf8575_direction_input(struct udevice *dev, unsigned offset)
 	int status;
 
 	plat->out |= BIT(offset);
-	status = pcf8575_i2c_write_le16(dev, plat->out);
+	status = pcf8575_i2c_write(dev, plat->out);
 
 	return status;
 }
@@ -105,7 +96,7 @@ static int pcf8575_direction_output(struct udevice *dev,
 	else
 		plat->out &= ~BIT(offset);
 
-	ret = pcf8575_i2c_write_le16(dev, plat->out);
+	ret = pcf8575_i2c_write(dev, plat->out);
 
 	return ret;
 }
@@ -114,7 +105,7 @@ static int pcf8575_get_value(struct udevice *dev, unsigned int offset)
 {
 	int             value;
 
-	value = pcf8575_i2c_read_le16(dev);
+	value = pcf8575_i2c_read(dev);
 
 	return (value < 0) ? value : ((value & BIT(offset)) >> offset);
 }
@@ -132,8 +123,11 @@ static int pcf8575_ofdata_platdata(struct udevice *dev)
 
 	int n_latch;
 
-	uc_priv->gpio_count = fdtdec_get_int(gd->fdt_blob, dev_of_offset(dev),
-					     "gpio-count", 16);
+	/*
+	 * Number of pins depends on the expander device and is specified
+	 * in the struct udevice_id (as in the Linue kernel).
+	 */
+	uc_priv->gpio_count = dev_get_driver_data(dev) * 8;
 	uc_priv->bank_name = fdt_getprop(gd->fdt_blob, dev_of_offset(dev),
 					 "gpio-bank-name", NULL);
 	if (!uc_priv->bank_name)
@@ -165,8 +159,9 @@ static const struct dm_gpio_ops pcf8575_gpio_ops = {
 };
 
 static const struct udevice_id pcf8575_gpio_ids[] = {
-	{ .compatible = "nxp,pcf8575" },
-	{ .compatible = "ti,pcf8575" },
+	{ .compatible = "nxp,pcf8575", .data = 2 },
+	{ .compatible = "ti,pcf8575", .data = 2 },
+	{ .compatible = "nxp,pca8574", .data = 1 },
 	{ }
 };
 
diff --git a/drivers/net/phy/mv88e61xx.c b/drivers/net/phy/mv88e61xx.c
index 7eff37b244..7e4d8f6a2d 100644
--- a/drivers/net/phy/mv88e61xx.c
+++ b/drivers/net/phy/mv88e61xx.c
@@ -45,7 +45,6 @@
 #define PORT_MASK(port_count)		((1 << (port_count)) - 1)
 
 /* Device addresses */
-#define DEVADDR_PHY(p)			(p)
 #define DEVADDR_SERDES			0x0F
 
 /* SMI indirection registers for multichip addressing mode */
@@ -202,6 +201,12 @@ struct mv88e61xx_phy_priv {
 	u8 phy_ctrl1_en_det_shift; /* 'EDet' bit field offset */
 	u8 phy_ctrl1_en_det_width; /* Width of 'EDet' bit field */
 	u8 phy_ctrl1_en_det_ctrl;  /* 'EDet' control value */
+	/* Bootstrap configuration */
+	/* If addr4 = 1 device is accessible from 0x10 address on MDIO bus */
+	u8 addr4;
+	/* If no_cpu = 1 switch is automatically setup, otherwise PHY reset is
+	   required from CPU for normal operation */
+	u8 no_cpu;
 };
 
 static inline int smi_cmd(int cmd, int addr, int reg)
@@ -268,8 +273,12 @@ static int mv88e61xx_reg_read(struct phy_device *phydev, int dev, int reg)
 	int smi_addr = priv->smi_addr;
 	int res;
 
-	/* In single-chip mode, the device can be addressed directly */
-	if (smi_addr == 0)
+	/*
+	 * In single-chip mode, the device can be addressed directly
+	 *
+	 * The mv88e6020 is accessed directly.
+	 */
+	if (smi_addr == 0 || priv->id == PORT_SWITCH_ID_6020)
 		return mdio_bus->read(mdio_bus, dev, MDIO_DEVAD_NONE, reg);
 
 	/* Wait for the bus to become free */
@@ -277,13 +286,13 @@ static int mv88e61xx_reg_read(struct phy_device *phydev, int dev, int reg)
 	if (res < 0)
 		return res;
 
-	/* Issue the read command */
+	/* Issue the write command */
 	res = mdio_bus->write(mdio_bus, smi_addr, MDIO_DEVAD_NONE, SMI_CMD_REG,
 			 smi_cmd_read(dev, reg));
 	if (res < 0)
 		return res;
 
-	/* Wait for the read command to complete */
+	/* Wait for the write command to complete */
 	res = mv88e61xx_smi_wait(mdio_bus, smi_addr);
 	if (res < 0)
 		return res;
@@ -305,8 +314,12 @@ static int mv88e61xx_reg_write(struct phy_device *phydev, int dev, int reg,
 	int smi_addr = priv->smi_addr;
 	int res;
 
-	/* In single-chip mode, the device can be addressed directly */
-	if (smi_addr == 0) {
+	/*
+	 * In single-chip mode, the device can be addressed directly
+	 *
+	 * The mv88e6020 is accessed directly.
+	 */
+	if (smi_addr == 0 || priv->id == PORT_SWITCH_ID_6020) {
 		return mdio_bus->write(mdio_bus, dev, MDIO_DEVAD_NONE, reg,
 				val);
 	}
@@ -408,7 +421,7 @@ static int mv88e61xx_phy_write_indirect(struct mii_dev *smi_wrapper, int dev,
 /* Wrapper function to make calls to phy_read_indirect simpler */
 static int mv88e61xx_phy_read(struct phy_device *phydev, int phy, int reg)
 {
-	return mv88e61xx_phy_read_indirect(phydev->bus, DEVADDR_PHY(phy),
+	return mv88e61xx_phy_read_indirect(phydev->bus, phydev->addr,
 					   MDIO_DEVAD_NONE, reg);
 }
 
@@ -416,24 +429,29 @@ static int mv88e61xx_phy_read(struct phy_device *phydev, int phy, int reg)
 static int mv88e61xx_phy_write(struct phy_device *phydev, int phy,
 		int reg, u16 val)
 {
-	return mv88e61xx_phy_write_indirect(phydev->bus, DEVADDR_PHY(phy),
+	return mv88e61xx_phy_write_indirect(phydev->bus, phydev->addr,
 					    MDIO_DEVAD_NONE, reg, val);
 }
 
 static int mv88e61xx_port_read(struct phy_device *phydev, u8 port, u8 reg)
 {
 	struct mv88e61xx_phy_priv *priv = phydev->priv;
+	struct mii_dev *mdio_bus = priv->mdio_bus;
 
-	return mv88e61xx_reg_read(phydev, priv->port_reg_base + port, reg);
+	/* Here we access the switch directly */
+	return mdio_bus->read(mdio_bus, priv->port_reg_base + port,
+			      MDIO_DEVAD_NONE, reg);
 }
 
 static int mv88e61xx_port_write(struct phy_device *phydev, u8 port, u8 reg,
 								u16 val)
 {
 	struct mv88e61xx_phy_priv *priv = phydev->priv;
+	struct mii_dev *mdio_bus = priv->mdio_bus;
 
-	return mv88e61xx_reg_write(phydev, priv->port_reg_base + port,
-				   reg, val);
+	/* Here we access the switch directly */
+	return mdio_bus->write(mdio_bus, priv->port_reg_base + port,
+			       MDIO_DEVAD_NONE, reg, val);
 }
 
 static int mv88e61xx_set_page(struct phy_device *phydev, u8 phy, u8 page)
@@ -872,14 +890,19 @@ static int mv88e61xx_phy_setup(struct phy_device *phydev, u8 phy)
 
 static int mv88e61xx_phy_config_port(struct phy_device *phydev, u8 phy)
 {
+	struct mv88e61xx_phy_priv *priv = phydev->priv;
+	u16 port_mask;
 	int val;
 
 	val = mv88e61xx_port_enable(phydev, phy);
 	if (val < 0)
 		return val;
 
-	val = mv88e61xx_port_set_vlan(phydev, phy,
-			1 << CONFIG_MV88E61XX_CPU_PORT);
+	port_mask = PORT_MASK(priv->port_count) & CONFIG_MV88E61XX_PHY_PORTS;
+	port_mask &= ~(1 << phy);
+	port_mask |= (1 << CONFIG_MV88E61XX_CPU_PORT);
+
+	val = mv88e61xx_port_set_vlan(phydev, phy, port_mask);
 	if (val < 0)
 		return val;
 
@@ -915,12 +938,21 @@ static int mv88e61xx_priv_reg_offs_pre_init(struct phy_device *phydev)
 	/*
 	 * Now try via port registers with device address 0x08
 	 * (88E6020 and compatible switches).
+	 *
+	 * When R0_LED/ADDR4 is set during bootstrap, one needs
+	 * to add 0x10 offset to switch addresses.
+	 *
+	 * The phydev->addr is set according to device tree address
+	 * of MDIO accessible device:
+	 *
+	 * When on board RO_LED/ADDR4 = 1 -> 0x10
+	 *                              0 -> 0x0
 	 */
-	priv->port_reg_base = 0x08;
+	priv->port_reg_base = 0x08 + phydev->addr;
 	priv->id = mv88e61xx_get_switch_id(phydev);
 	if (priv->id != 0xfff0) {
-		priv->global1 = 0x0F;
-		priv->global2 = 0x07;
+		priv->global1 = 0x0F + phydev->addr;
+		priv->global2 = 0x07 + phydev->addr;
 		return 0;
 	}
 
@@ -1043,7 +1075,10 @@ static int mv88e61xx_phy_config(struct phy_device *phydev)
 
 	for (i = 0; i < priv->port_count; i++) {
 		if ((1 << i) & CONFIG_MV88E61XX_PHY_PORTS) {
-			phydev->addr = i;
+			if (phydev->addr)
+				phydev->addr += i;
+			else
+				phydev->addr = i;
 
 			res = mv88e61xx_phy_enable(phydev, i);
 			if (res < 0) {
@@ -1177,6 +1212,57 @@ int phy_mv88e61xx_init(void)
 	return 0;
 }
 
+static int mv88e61xx_read_bootstrap(struct phy_device *phydev)
+{
+	struct mv88e61xx_phy_priv *priv = phydev->priv;
+	struct mii_dev *mdio_bus = priv->mdio_bus;
+	int val;
+
+	/* mv88e6020 - ID = 0x0200 (REG 3 on non PHY port) */
+	if (priv->id == PORT_SWITCH_ID_6020) {
+		/* Prepare to read scratch and misc register */
+		mdio_bus->write(mdio_bus, priv->global2, 0,
+				0x1a /*MV_SCRATCH_MISC*/,
+				(0x71 /*MV_CONFIG_DATA1*/ << 8));
+
+		val = mdio_bus->read(mdio_bus, priv->global2, 0,
+				     0x1a /*MV_SCRATCH_MISC*/);
+
+		if (val & (1 << 0))
+			priv->no_cpu = 1;
+		if (val & (1 << 4))
+			priv->addr4 = 1;
+		debug("mv88e6020: no_cpu=%d addr4=%d\n", priv->no_cpu,
+		      priv->addr4);
+	}
+
+	return 0;
+}
+
+static int mv88e61xx_setup_leds(struct phy_device *phydev)
+{
+	struct mv88e61xx_phy_priv *priv = phydev->priv;
+	struct mii_dev *mdio_bus = priv->mdio_bus;
+
+	/* mv88e6020 - ID = 0x0200 (REG 3 on non PHY port) */
+	if (priv->id == PORT_SWITCH_ID_6020) {
+		/* Port 0 */
+		mdio_bus->write(mdio_bus, priv->port_reg_base + 0, 0,
+				0x16 /* LED control register*/,
+				(1 << 15) | (0x0 /* Control LED{01}*/ << 12) |
+				(0xF << 4) /* LED1 Force ON */ |
+				0x1 /* LED0 100 Link/Act */);
+
+		/* Port 1 */
+		mdio_bus->write(mdio_bus, priv->port_reg_base + 1, 0,
+				0x16 /* LED control register */,
+				(1 << 15) | (0x0 /* Control LED{01}*/ << 12) |
+				(0xF << 4) /* LED1 Force ON */ |
+				0x1 /* LED0 100 Link/Act */);
+	}
+
+	return 0;
+}
 /*
  * Overload weak get_phy_id definition since we need non-standard functions
  * to read PHY registers
@@ -1188,6 +1274,10 @@ int get_phy_id(struct mii_dev *bus, int smi_addr, int devad, u32 *phy_id)
 	struct mii_dev temp_mii;
 	int val;
 
+	memset(&temp_phy, 0, sizeof(temp_phy));
+	memset(&temp_priv, 0, sizeof(temp_priv));
+	memset(&temp_mii, 0, sizeof(temp_mii));
+
 	/*
 	 * Buid temporary data structures that the chip reading code needs to
 	 * read the ID
@@ -1197,6 +1287,8 @@ int get_phy_id(struct mii_dev *bus, int smi_addr, int devad, u32 *phy_id)
 	temp_phy.priv = &temp_priv;
 	temp_mii.priv = &temp_phy;
 
+	temp_phy.addr = smi_addr;
+
 	/*
 	 * get_phy_id() can be called by framework before mv88e61xx driver
 	 * probing, in this case the global register offsets are not
@@ -1207,13 +1299,36 @@ int get_phy_id(struct mii_dev *bus, int smi_addr, int devad, u32 *phy_id)
 	if (val < 0)
 		return val;
 
-	val = mv88e61xx_phy_read_indirect(&temp_mii, 0, devad, MII_PHYSID1);
+	mv88e61xx_read_bootstrap(&temp_phy);
+
+	/*
+	 * When switch is configured to work with CPU (i.e. NO_CPU == 0), PHYs
+	 * require reset (to at least single one) to have its registers
+	 * accessible.
+	 */
+	if (!temp_priv.no_cpu && temp_priv.id == PORT_SWITCH_ID_6020) {
+		/* Reset PHY */
+		val = mv88e61xx_phy_read_indirect(&temp_mii, temp_phy.addr,
+						  devad, MII_BMCR);
+		if (val & BMCR_PDOWN)
+			val &= ~BMCR_PDOWN;
+
+		mv88e61xx_phy_write_indirect(&temp_mii, temp_phy.addr, devad,
+					     MII_BMCR, val);
+	}
+
+	mv88e61xx_setup_leds(&temp_phy);
+
+	/* Read PHY_ID */
+	val = mv88e61xx_phy_read_indirect(&temp_mii, temp_phy.addr, devad,
+					  MII_PHYSID1);
 	if (val < 0)
 		return -EIO;
 
 	*phy_id = val << 16;
 
-	val = mv88e61xx_phy_read_indirect(&temp_mii, 0, devad, MII_PHYSID2);
+	val = mv88e61xx_phy_read_indirect(&temp_mii, temp_phy.addr, devad,
+					  MII_PHYSID2);
 	if (val < 0)
 		return -EIO;
 
diff --git a/include/configs/imx6ull-inverter.h b/include/configs/imx6ull-inverter.h
new file mode 100644
index 0000000000..5b93caf4c7
--- /dev/null
+++ b/include/configs/imx6ull-inverter.h
@@ -0,0 +1,334 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Board configuration file for Kostal KIE imx6ULL
+ * 
+ * Copyright (C) 2024 Kostal Industrie Elektrik GmbH & Co. KG
+ * Copyright (C) 2024 Henry Hermanns <h.hermanns@kostal.com>
+ *
+ * Copyright (C) 2019 Parthiban Nallathambi <pn@denx.de>
+ */
+#ifndef __KIE_ULL_H
+#define __KIE_ULL_H
+
+#include <linux/sizes.h>
+#include "mx6_common.h"
+
+/* SPL options */
+#include "imx6_spl.h"
+
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+/* Environment in mmcblk0boot2 */
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_SYS_MMC_ENV_PART		2
+#define MMC_ROOTFS_DEV		1
+#define MMC_ROOTFS_PART		1
+
+/* Console configs */
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* MMC Configs */
+
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
+
+/* I2C configs */
+#ifdef CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_SPEED		100000
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+/* Physical Memory Map */
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE			SZ_512M
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* USB Configs */
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	1
+
+#define CONFIG_IMX_THERMAL
+
+#define CONFIG_FEC_ENET_DEV		1
+
+/* environment organization */
+
+#define ENV_MMC \
+	"addcon=setenv bootargs ${bootargs} console=${console},${baudrate} ${bootinfo}\0" \
+	"addip=setenv bootargs ${bootargs} ip=dhcp\0" \
+	"addstaticip=setenv bootargs ${bootargs} ip=192.168.0.20::192.168.0.1:255.255.255.0:scb-factory:lan1\0" \
+	"altbootcmd=if test -e ${mmcpart};then if itest ${rootpart} -eq 3; " \
+		"then setenv rootpart 4; setenv mmcfitpart 2; " \
+		"else setenv rootpart 3; setenv mmcfitpart 1; fi; " \
+		"else setenv rootpart 3; setenv mmcfitpart 1; fi; " \
+		"setenv bootcount 0; saveenv; boot\0" \
+	"altboot=if itest ${bootcount} -gt ${bootlimitrescue}; " \
+		"then run swupdate; else run bootcmdaltmmc; fi;\0"\
+	"bootcmdaltmmc=if test ${mmxpart} -eq 1; then setenv mmxpart 2; " \
+			"else setenv mmcpart 1; fi;run mmc_mmc_fit\0" \
+	"hab_check_img=" \
+		"if hab_auth_img ${loadaddr} ${filesize}; then " \
+			"echo 'HAB auth OK, booting!'; " \
+		"else " \
+			"echo 'HAB authentication FAILED'; reset; " \
+		"fi\0" \
+	"bootlimitrescue=6\0" \
+	"mmcdev=" __stringify(MMC_ROOTFS_DEV) "\0" \
+	"mmcpart=" __stringify(MMC_ROOTFS_PART) "\0" \
+	"bootdelay=0\0" \
+	"silent=1\0" \
+	"optargs=rw rootwait quiet splash plymouth.ignore-serial-consoles\0" \
+	"mmcautodetect=yes\0" \
+	"mmcrootfstype=ext3\0" \
+	"rootpart=3\0" \
+	"mmcfit_name=fitImage\0" \
+	"mmcfitpart=1\0" \
+	"mmcloadfit=echo Reading fit image from 0:${mmcfitpart};" \
+		"load mmc 0:${mmcfitpart} ${fit_addr} ${mmcfit_name}\0" \
+	"mmcargs=setenv bootargs " \
+		"root=/dev/mmcblk${mmcdev}p${rootpart} ${optargs} " \
+		"rootfstype=${mmcrootfstype}\0" \
+	"mmc_mmc_fit=run mmcloadfit; run hab_check_img;" \
+		"run mmcargs addcon; bootm ${loadaddr}#conf-imx${soc_type}-kie-inverter.dtb\0" \
+	"swupdate_args=setenv bootargs root=/dev/ram splash plymouth.ignore-serial-consoles\0"	\
+	"swupdate=mmc dev 0 1;mmc read ${fit_addr} 0 8000;" \
+		"run swupdate_args addcon;bootm ${fit_addr}#conf-imx${soc_type}-kie-inverter.dtb\0" \
+	"swupdate_usb=if usb start && usb storage;then " \
+		"load usb 0:1 ${loadaddr} ${swupdate_usb_name};" \
+		"run hab_check_img;" \
+		"run swupdate_args addcon; bootm ${loadaddr}#conf-imx${soc_type}-kie-inverter.dtb;" \
+	"fi\0" \
+	"swupdate_tftp=if dhcp ${tftp_rootpath}/${swupdate_usb_name};then " \
+		"run hab_check_img; run swupdate_args addcon addstaticip; bootm ${loadaddr}#conf-imx${soc_type}-kie-inverter.dtb;" \
+	"fi\0" \
+	"tftp_rootpath=kostal\0" \
+	"swupdate_usb_name=rescue-initramfs.itb.signed\0" \
+	"kernel_file=kostal/fitImage\0" \
+	"download_kernel=" \
+		"dhcp ${loadaddr} ${kernel_file};\0" \
+	"nfsargs=setenv bootargs " \
+	"root=/dev/nfs rw "	  \
+	"nfsroot=${serverip}:${rootpath},nolock,nfsvers=3" \
+	"\0" \
+	"rootpath=/srv/tftp/kostal/rootfs\0" \
+	"boot_tftp=" \
+	"if run download_kernel; then "	  \
+	     "setenv bootargs ${bootargs} console=${console} "	  \
+	     "root=/dev/sda5 rootwait rootfstype=ext4;" \
+	     "bootm ${loadaddr}#conf-imx${soc_type}-kie-inverter.dtb;reset;" \
+	"fi\0" \
+	"boot_nfs=" \
+	"if run download_kernel; then "	  \
+	     "run nfsargs;"	  \
+	     "run addip;"	  \
+	     "setenv bootargs ${bootargs} console=${console};"	  \
+	     "bootm ${loadaddr}#conf-imx${soc_type}-kie-inverter.dtb;reset;" \
+	"fi\0" \
+	"ledon=led red on; led green on; sleep 0.1\0" \
+	"ledoff=led red off; led green off\0" \
+	"kbd_read=" \
+		"setenv kbdres 0;" \
+		"setenv k;" \
+		"setenv v 1;" \
+		"for k in 0 1 2 3 4 5; do " \
+			"if gpio input kbd${k}; then " \
+				"setexpr kbdres ${kbdres} + ${v};" \
+			"fi;" \
+			"setexpr v ${v} * 2;" \
+		"done;" \
+		"echo Recognized keys: ${kbdres}\0" \
+	"start_swupdate_tftp=" \
+		"run dynamicip;" \
+		"if run check_secfuse; then " \
+			"echo secfuse unfused.; " \
+			"run factory1; " \
+		"else echo secfuse enabled; " \
+			"setenv bootinfo boot_type=factory;" \
+			"setenv swupdate_usb_name factory-image-fit.itb.signed;" \
+			"run swupdate_tftp; " \
+		"fi\0" \
+	"start_swupdate_usb=" \
+		"setenv bootinfo boot_type=swu boot_keys=${kbdres};" \
+		"run swupdate_usb\0" \
+	"boot_switch=" \
+		"if itest ${kbdres} == 24; then " \
+			"echo booting from tftp...;" \
+			"run start_swupdate_tftp;" \
+		"fi;" \
+		"if itest ${kbdres} == 21; then "	  \
+			"echo booting from usb...;" \
+			"run start_swupdate_usb;" \
+		"fi;" \
+		"if itest ${kbdres} == 18; then "	  \
+			"echo booting from usb...;" \
+			"run start_swupdate_usb;" \
+		"fi;" \
+		"if itest ${kbdres} == 6; then "	  \
+			"echo booting from usb...;" \
+			"run start_swupdate_usb;" \
+		"fi\0" \
+	"net_update_uboot=" \
+	   "if dhcp kostal/SPL-emmc.signed; then " \
+	       "setexpr fw_sz ${filesize} / 0x200; " \
+	       "setexpr fw_sz ${fw_sz} + 1; "  \
+	       "mmc dev 0 1; " \
+	       "mmc write ${loadaddr} 2 ${fw_sz};" \
+	       "mmc dev 0 0; " \
+	   "fi;" \
+	   "if tftpboot kostal/u-boot-ivt.img-emmc.signed; then " \
+	       "setexpr fw_sz ${filesize} / 0x200; " \
+	       "setexpr fw_sz ${fw_sz} + 1; "  \
+	       "mmc dev 0 1; " \
+	       "mmc write ${loadaddr} 8a ${fw_sz}; " \
+	       "mmc dev 0 0; " \
+	   "fi\0" \
+	"update_uboot=usb start; " \
+	    "if usb storage; then " \
+		"load usb 0:1 ${loadaddr} SPL-emmc.signed; " \
+		"setexpr fw_sz ${filesize} / 0x200; " \
+		"setexpr fw_sz ${fw_sz} + 1; " \
+		"mmc dev 0 1; " \
+		"mmc write ${loadaddr} 2 ${fw_sz}; " \
+		"load usb 0:1 ${loadaddr} u-boot-ivt.img-emmc.signed; " \
+		"setexpr fw_sz ${filesize} / 0x200; " \
+		"setexpr fw_sz ${fw_sz} + 1; "  \
+		"mmc write ${loadaddr} 8a ${fw_sz}; " \
+		"mmc dev 0 0; " \
+	    "fi\0" \
+	"check_secfuse=if fuse cmp 0 6 0x0; then true; else if fuse cmp 0 6 0x80040; then true; else false; fi; fi;\0" \
+	"watchdogr=gpio set GPIO1_05; gpio clear GPIO1_05;\0" \
+	"put_logfile=run watchdogr; tftpput ${logaddr} ${logsz} 192.168.0.1:factorylog1.txt;\0" \
+	"staticip= setenv serverip 192.168.0.1; " \
+		"setenv ipaddr 192.168.0.20; " \
+		"setenv netmask 255.255.255.0; \0" \
+	"dynamicip= dhcp;" \
+		"setenv serverip 192.168.0.1; \0" \
+	"logaddr=0x83400000\0" \
+	"logtxt01=mw.l ${logaddrptr} 0x0a206f67; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"setexpr logsz ${logsz} + 0x04; " \
+		"run put_logfile;\0" \
+	"logtxt02=mw.l ${logaddrptr} 0x20746f67; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x656c6966; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x0a202020; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"setexpr logsz ${logsz} + 0x0c;" \
+		"run put_logfile;\0" \
+	"logtxt03=mw.l ${logaddrptr} 0x20676973; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x656e6f64; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x0a202020; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"setexpr logsz ${logsz} + 0x0c; " \
+		"run put_logfile;\0" \
+	"logtxt04= " \
+		"mw.l ${logaddrptr} 0x20636573; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x656e6f64; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x0a202020; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"setexpr logsz ${logsz} + 0x0c; " \
+		"run put_logfile;\0" \
+	"logtxt05= " \
+		"mw.l ${logaddrptr} 0x7364656c; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x69616620; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x0a64656c; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"setexpr logsz ${logsz} + 0x0c; " \
+		"run put_logfile;\0" \
+	"logtxt06= " \
+		"mw.l ${logaddrptr} 0x7364656c; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"mw.l ${logaddrptr} 0x0a6b6f20; " \
+		"setexpr logaddrptr ${logaddrptr} + 4; " \
+		"setexpr logsz ${logsz} + 0x08; " \
+		"run put_logfile;\0" \
+	"putreadyfile= " \
+		"mw.l 0x83400100 0x72203166; " \
+		"mw.l 0x83400104 0x79646165; " \
+		"tftpput 0x83400100 8 192.168.0.1:ready1;\0" \
+	"fuse_sec= " \
+		"setexpr fuseerror 1; " \
+		"if tftpboot ${fusefile}; then " \
+			"echo got fuse file; " \
+			"run logtxt02; " \
+			"if fuse progm -y 3 0 ${loadaddr} 8; then " \
+				"fuse sense 3 0 8;" \
+				"echo sig done; " \
+				"run logtxt03; " \
+				"if fuse prog -y 0 6 0x2; then " \
+				"fuse sense 0 6;" \
+				"echo sec fused; " \
+				"run logtxt04; " \
+				"setexpr fuseerror 0; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"echo no fuse file; " \
+		"fi; " \
+		"run finalfeedback;\0" \
+	"finalfeedback=" \
+		"if itest ${fuseerror} != 0; then " \
+			"led red on; " \
+			"while true; do echo .; sleep 5; done; " \
+		"else " \
+			"if i2c probe 0x20; then  " \
+				"echo Found IO-Expander.; " \
+				"run logtxt06; " \
+				"led green on; " \
+				"led red on; " \
+			"else  " \
+				"echo No IO-Expander, led feedback will not work.; " \
+				"run logtxt05; " \
+			"fi; " \
+			"run putreadyfile; " \
+			"sleep 5; " \
+			"reset; " \
+		"fi;\0" \
+	"factory1=setexpr logaddrptr ${logaddr}; setexpr logsz 0; run logtxt01; run fuse_sec;\0" \
+	"fusefile=SRK_1_2_3_4_fuse.bin\0" \
+	"version=1.5\0"
+
+/* Default environment */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"fdt_high=0xffffffff\0" \
+	"console=ttymxc0,115200n8\0" \
+	"addcon=setenv bootargs ${bootargs} console=${console},${baudrate}\0" \
+	"fit_addr=0x82000000\0" \
+	ENV_MMC
+
+#define CONFIG_BOOTCOMMAND "run ledon; run kbd_read; run ledoff; echo U-Boot-env version ${version}; run boot_switch; run mmc_mmc_fit; run swupdate;"
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(MMC, mmc, 1) \
+	func(DHCP, dhcp, na)
+
+#include <config_distro_bootcmd.h>
+
+#endif /* __KIE_ULL_H */
